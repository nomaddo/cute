package cute_test

import (
	"encoding/json"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"

	cute "cute/pkg/cute"
)

type RubySFEN struct {
	Move int    `json:"move"`
	SFEN string `json:"sfen"`
}

func TestSFENComparisonWithBioshogi(t *testing.T) {
	// Check if ruby is available
	if _, err := exec.LookPath("ruby"); err != nil {
		t.Skip("ruby not found in PATH")
	}

	// Find repository root
	_, repoRoot, err := cute.FindConfigPath()
	if err != nil {
		t.Fatalf("failed to locate repository root: %v", err)
	}

	// Check if bioshogi is installed
	checkCmd := exec.Command("ruby", "-e", "require 'bioshogi'")
	if err := checkCmd.Run(); err != nil {
		t.Skip("bioshogi gem not installed (run: gem install bioshogi)")
	}

	testDir := filepath.Join(repoRoot, "pkg", "cute", "testdata")
	files, err := cute.CollectKIF(testDir)
	if err != nil {
		t.Fatalf("failed to collect kifs: %v", err)
	}
	if len(files) == 0 {
		t.Fatal("no .kif files found in test dir")
	}

	// Limit to first 5 files for faster testing
	if len(files) > 5 {
		files = files[:5]
	}

	rubyScript := filepath.Join(repoRoot, "tools", "generate_sfen.rb")
	if _, err := os.Stat(rubyScript); err != nil {
		t.Fatalf("ruby script not found at %s: %v", rubyScript, err)
	}

	successCount := 0
	for _, kifPath := range files {
		t.Run(filepath.Base(kifPath), func(t *testing.T) {
			// Generate SFENs using Ruby/bioshogi
			cmd := exec.Command("ruby", rubyScript, kifPath)
			output, err := cmd.Output()
			if err != nil {
				if exitErr, ok := err.(*exec.ExitError); ok {
					t.Fatalf("ruby script failed: %v\nstderr: %s", err, string(exitErr.Stderr))
				}
				t.Fatalf("failed to run ruby script: %v", err)
			}

			var rubySfens []RubySFEN
			if err := json.Unmarshal(output, &rubySfens); err != nil {
				t.Fatalf("failed to parse ruby output: %v", err)
			}

			if len(rubySfens) == 0 {
				t.Fatal("no SFENs generated by ruby script")
			}

			// Generate SFENs using Go
			board, err := cute.LoadBoardFromKIF(kifPath)
			if err != nil {
				t.Fatalf("failed to load board: %v", err)
			}

			// Compare each position
			moveCount := board.MoveCount()
			mismatchCount := 0
			for i := 0; i <= moveCount && i < len(rubySfens); i++ {
				goSfen, err := board.SFENAt(i)
				if err != nil {
					t.Fatalf("failed to generate Go SFEN at move %d: %v", i, err)
				}

				rubySfen := rubySfens[i].SFEN

				// Normalize SFENs for comparison (bioshogi may format differently)
				goNorm := normalizeSFEN(goSfen)
				rubyNorm := normalizeSFEN(rubySfen)

				if goNorm != rubyNorm {
					mismatchCount++
					if mismatchCount <= 3 { // Only show first 3 mismatches
						t.Errorf("SFEN mismatch at move %d:\nGo:   %s\nRuby: %s", i, goSfen, rubySfen)
					}
				}
			}

			if mismatchCount > 0 {
				t.Errorf("Total mismatches: %d/%d positions", mismatchCount, min(moveCount+1, len(rubySfens)))
			} else {
				successCount++
				t.Logf("All %d positions match", min(moveCount+1, len(rubySfens)))
			}
		})
	}

	if successCount == 0 {
		t.Error("no KIF files had matching SFENs")
	} else {
		t.Logf("Successfully compared %d/%d KIF files", successCount, len(files))
	}
}

// normalizeSFEN normalizes SFEN string for comparison
func normalizeSFEN(sfen string) string {
	// Trim whitespace
	sfen = strings.TrimSpace(sfen)
	// Ensure consistent spacing
	fields := strings.Fields(sfen)
	return strings.Join(fields, " ")
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func TestSFENNormalization(t *testing.T) {
	tests := []struct {
		name     string
		sfen1    string
		sfen2    string
		expected bool
	}{
		{
			name:     "identical",
			sfen1:    "lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1",
			sfen2:    "lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1",
			expected: true,
		},
		{
			name:     "extra whitespace",
			sfen1:    "lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1",
			sfen2:    "lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL  b  -  1",
			expected: true,
		},
		{
			name:     "different position",
			sfen1:    "lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1",
			sfen2:    "lnsgkgsnl/1r5b1/ppppppppp/9/9/7P1/PPPPPPP1P/1B5R1/LNSGKGSNL w - 2",
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			norm1 := normalizeSFEN(tt.sfen1)
			norm2 := normalizeSFEN(tt.sfen2)
			result := norm1 == norm2
			if result != tt.expected {
				t.Errorf("expected %v, got %v\nnorm1: %s\nnorm2: %s", tt.expected, result, norm1, norm2)
			}
		})
	}
}
